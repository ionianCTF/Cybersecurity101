# Cyber Security — Επιθέσεις Εφαρμογών Ιστού (Web Application Attacks)

<div class="w3-clear nextprev">
  <a class="w3-left w3-btn" href="cybersecurity_network_attacks.php">&#10094; Previous</a>
  <a class="w3-right w3-btn" href="cybersecurity_wifi_attacks.php">Next &#10095;</a>
</div>

---

Ήταν πολλές οι web εφαρμογές σήμερα, και χρησιμοποιούνται για τον έλεγχο σχεδόν οτιδήποτε μπορείς να φανταστείς. Σε αυτή την ενότητα θα εξετάσουμε τις επιθέσεις και την ασφάλεια των web εφαρμογών.

---

## IDOR (Insecure Direct Object Reference)

Οι ευπάθειες IDOR εμφανίζονται όταν οι προγραμματιστές δεν έχουν υλοποιήσει σωστά ελέγχους εξουσιοδότησης για την πρόσβαση σε πόρους.

![IDOR](img_idor.svg)

Η Eve, απλά αλλάζοντας ένα αναγνωριστικό — π.χ. το παράμετρο REST του εγγράφου — μπορεί να αποκτήσει πρόσβαση στα έγγραφα της Alice.

Αυτό συμβαίνει όταν η web εφαρμογή δεν επιβάλλει έλεγχο πρόσβασης ανάμεσα στα αντικείμενα, επιτρέποντας σε επιτιθέμενους να απαριθμήσουν (enumerate) τιμές και να δοκιμάσουν πρόσβαση σε άλλα δεδομένα.

Παράδειγμα ψευδοκώδικα χωρίς έλεγχο εξουσιοδότησης:

```php
$id = getInputFromUser();
$doc = getDocument($id);
return $doc;
```

Ο κώδικας παραπάνω ζητάει είσοδο από τον χρήστη, δεν κάνει καμία επικύρωση ή φιλτράρισμα, στη συνέχεια κάνει άμεση αναζήτηση (lookup) με τη `getDocument` και επιστρέφει το έγγραφο.

Μια καλύτερη υλοποίηση θα ήταν να ελέγχει τα προνόμια:

```php
$id = getInputFromUser();
$user = findUsername();
$doc = "";
if (hasAccessToDocument($user, $id)) {
  $doc = getDocument($id);
} else {
  $doc = "Not authorized for this document";
}
return $doc;
```

Τέτοιες ευπάθειες είναι εύκολες στον εντοπισμό επειδή μπορείς απλώς να αλλάξεις έναν αριθμό και να δεις αν αποκτάς πρόσβαση σε δεδομένα κάποιου άλλου. Ο έλεγχος εξουσιοδότησης πριν την ανάκτηση του πόρου αποτρέπει αυτή την ευπάθεια.

> **Σημείωση:** Ψευδοκώδικας (pseudo code) σημαίνει ότι μοιάζει με πραγματικό κώδικα αλλά μπορεί να μην εκτελείται άμεσα — χρησιμοποιείται για παραδείγματα.

---

## Αποφυγή «Μαγικών Αριθμών» (Avoiding "Magic Numbers")

Μια εφαρμογή πρέπει να αποφεύγει τη χρήση ακολουθιών αριθμών όταν αναφέρεται σε δεδομένα. Στο παράδειγμα του IDOR, τα έγγραφα είχαν αναγνωριστικά από `1000` έως `1002`. Αυτοί οι αριθμοί αποκαλούνται μερικές φορές "magic numbers" καθώς δείχνουν άμεσα σε έναν πόρο στον server (π.χ. στη βάση δεδομένων) και όλες οι τιμές μπορούν εύκολα να απαριθμηθούν. Ένας επιτιθέμενος μπορεί να δοκιμάσει όλα τα αναγνωριστικά εγγράφων από `0` έως `10000` και να καταγράψει αποτελέσματα που επιστρέφουν δεδομένα.

Εκτός από τον σωστό έλεγχο εξουσιοδότησης, είναι χρήσιμο να χρησιμοποιούνται GUID (Globally Unique Identifier) ή UUID (Universally Unique Identifier) όταν αναφερόμαστε σε πόρους. Αυτά τα αναγνωριστικά έχουν ενσωματωμένη εντροπία και είναι πρακτικά αδύνατο να απαριθμηθούν.

Ένα παράδειγμα GUID:

- `3377d5a6-236e-4d68-be9c-e91b22afd216`

> **Σημείωση:** Αν εξετάσετε τα μαθηματικά πίσω από την εύρεση αυτού του αριθμού, γίνεται γρήγορα σαφές ότι η απλή απαρίθμηση είναι πρακτικά ανέφικτη — το GUID/UUID αποτρέπει την enumeration.

---

## SQL Injection

Πολλές web εφαρμογές συνδέονται με βάσεις δεδομένων. Η βάση δεδομένων αποθηκεύει όλες τις πληροφορίες που θέλει να χρησιμοποιήσει και να διαχειριστεί η εφαρμογή.

Το SQL Injection είναι μια τεχνική που επιτρέπει σε επιτιθέμενους να χειραγωγήσουν το SQL (Structured Query Language) που χρησιμοποιεί ο προγραμματιστής. Αυτό συμβαίνει συνήθως λόγω έλλειψης καθαρισμού (sanitization) των εισερχόμενων δεδομένων.

![SQL Injection](img_sqlinjection.svg)

Στο παράδειγμα η Eve εισάγει την τιμή: `1000' OR '1'='1`

Αυτό κάνει το αποτέλεσμα του SQL query να επιστρέφει όλες τις γραμμές του πίνακα γιατί η συνθήκη αξιολογείται πάντα ως αληθής (`'1'='1'`). Υπάρχουν πολλοί διαφορετικοί SQL τεχνικοί χειρισμοί — αυτό είναι μόνο ένα παράδειγμα.

Παράδειγμα ψευδοκώδικα με ευπάθεια SQL Injection:

```php
$username = getUserName();
$pw = getPassword();
$user = mysql_query("SELECT * FROM userTable WHERE username = $username AND password =  $pw");
if ($user) {
  $loggedIn = True;
} else {
  $loggedIn = False;
}
```

Εδώ δεν υπάρχει καμία φιλτράρισμα στα `username` και `password` — χρησιμοποιούνται απευθείας στο SQL, επιτρέποντας στην `$loggedIn` να οριστεί σε `True` εάν το query επιστρέψει οποιοδήποτε αποτέλεσμα.

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό μέσω μιας crafted URL όπως:

```
/login?username=admin&password=password' OR '1'='1
```

Το τελικό SQL που εκτελείται θα μοιάζει με:

```
SELECT * FROM userTable WHERE username = 'admin' AND password = 'password' OR '1'='1'
```

Η συνιστώμενη λύση είναι η χρήση παραμετροποιημένων (parameterized) queries. Σε μια παραμετροποιημένη ερώτηση, ο προγραμματιστής δηλώνει σαφώς κάθε είσοδο ως συγκεκριμένο τύπο και τιμή — το SQL engine δεν την ερμηνεύει ως δομή SQL αλλά ως δεδομένο.

Παράδειγμα ασφαλούς implemention:

```java
$username = getUserName();
$pw = getPassword();
$parameterizedQuery = prepare_query("SELECT * FROM userTable where username = ? and password = ?");
$parameterizedQuery.setString(1, $username);
$parameterizedQuery.setString(2, $password);
$user = parameterizedQuery.execute();
if ($user) {
  $loggedIn = True;
} else {
  $loggedIn = False;
}
```

> **Σημείωση:** Το SQL Injection είναι δυνατό επειδή οι προγραμματιστές δεν καθαρίζουν σωστά την είσοδο των χρηστών, επιτρέποντας στον επιτιθέμενο να παραπλανήσει την εφαρμογή και τη βάση δεδομένων ώστε να εκτελέσει μη εξουσιοδοτημένο SQL κώδικα.

---

## XSS (Cross-Site Scripting)

Το XSS χρησιμοποιεί τον server για να επιτεθεί στους επισκέπτες του server. Η επίθεση δεν στοχεύει απαραίτητα τον server, αλλά τους χρήστες του.

Ο server απλώς αντανακλά (reflects) τις τιμές του επιτιθέμενου — συνήθως JavaScript — προς τους επισκέπτες, οι οποίοι εκτελούν τον επιθετικό κώδικα στο δικό τους πρόγραμμα περιήγησης. Ο επιτιθέμενος πρέπει να δημιουργήσει είσοδο που ο server δεν καθαρίζει, έτσι όταν ένας χρήστης ανοίξει ένα crafted σύνδεσμο ή επισκεφτεί μια σελίδα που περιέχει την επιθετική είσοδο, ο χρήστης θα εκτελέσει τον κώδικα του επιτιθέμενου.

![XSS](img_xss.svg)

Αυτό το είδος επίθεσης λέγεται Reflected XSS: ο επιτιθέμενος βρίσκει την ευπάθεια, στέλνει έναν σύνδεσμο σε ένα ανύποπτο θύμα και όταν ο θύμας τον ανοίξει, ο server επιστρέφει την επιθετική τιμή που εκτελείται στο πρόγραμμα περιήγησης του θύματος.

Παράδειγμα ψευδοκώδικα:

```php
$nickname = etNickName();
echo "Greeting $nickname, nice to meet you!";
```

Ένας άλλος τύπος είναι το Stored XSS (αποθηκευμένο). Εκεί ο επιτιθέμενος μπορεί να αποθηκεύσει κακόβουλο JavaScript στην εφαρμογή (π.χ. σε ένα πεδίο σχολίων) και αυτό θα εκτελείται κάθε φορά που κάποιος επισκέπτεται τη σελίδα.

![Stored XSS](img_stored-xss.svg)

Το XSS μπορεί να επιτύχει πολλά, όπως:

- Κλοπή cookies που χρησιμοποιούνται για authentication
- Defacement της ιστοσελίδας — εμφάνιση περιεχομένου που δεν επιθυμεί ο server
- Phishing χρηστών με ψεύτικες φόρμες εισόδου

Αντιμετώπιση XSS — καλές πρακτικές:

- Ο webserver να επιστρέφει `CSP` (Content Security Policy) headers που περιορίζουν αυστηρά από πού και πώς το JavaScript μπορεί να φορτώνεται/εκτελείται.
- Κωδικοποίηση/escape (encode) με ασφάλεια της εξόδου που επιστρέφει ο server, μετατρέποντας ειδικούς χαρακτήρες HTML σε ασφαλείς οντότητες.

---

## HTML Encoding

Η HTML κωδικοποίηση επιτρέπει στη web εφαρμογή να επιστρέφει συνήθως μη ασφαλείς χαρακτήρες με ασφαλή τρόπο. Παραδείγματα ειδικών χαρακτήρων και των HTML οντοτήτων τους:

| Ειδικός Χαρακτήρας | HTML Entity |
|---|---:|
| `<` | `&lt;` |
| `>` | `&gt;` |
| `"` | `&quot;` |
| `&` | `&amp;` |
| `'` | `&apos;` |

Αυτό παράγει έξοδο που μπορεί να εμφανιστεί με ασφάλεια. Στη συνέχεια, μπορούμε στον client-side (JavaScript) να αποκωδικοποιήσουμε με ασφάλεια τις οντότητες αν χρειάζεται.

---

## CSP (Content Security Policy)

Ο webserver μπορεί να ελέγξει τι είδους JavaScript επιτρέπεται να τρέχει στην ιστοσελίδα. Αυτό δεν αφαιρεί τις ευπάθειες αλλά προσθέτει ένα επιπλέον επίπεδο άμυνας (defense-in-depth) όταν υπάρχει κάποια άγνωστη ευπάθεια.

Μια αυστηρή CSP παρέχει λίστα με όλες τις αποδεκτές πηγές JavaScript για την εφαρμογή.

Επιπλέον, είναι σύνηθες η CSP να απαγορεύει την εκτέλεση inline JavaScript.

Για ευκολότερη υλοποίηση και ανίχνευση επιθέσεων, η CSP επιτρέπει επίσης την αναφορά (reporting) παραβιάσεων σε ένα URL που ορίζει ο server.

---

## Σάρωση Web Εφαρμογών (Web-Application Scanning)

Υπάρχουν πολλά εργαλεία σάρωσης web εφαρμογών που εντοπίζουν ευπάθειες όπως SQL Injection και XSS. Σε αντίθεση με έναν network vulnerability scanner, ένας web-application scanner συχνά βασίζεται σε ευρετικές μεθόδους (heuristics) αντί για λίστες υπογραφών.

Οι web-application scanners είναι ιδιαίτερα χρήσιμοι όταν ενσωματώνονται στη διαδικασία ανάπτυξης, π.χ. σε CI (Continuous Integration) και CD (Continuous Delivery) pipelines.

---

