# Επιθέσεις Δικτύου (Network Attacks)

Οι επιθέσεις σε πρωτόκολλα και εφαρμογές που φιλοξενούνται στο δίκτυο είναι πολλές. Οι Web Εφαρμογές καλύπτονται σε ξεχωριστή ενότητα αυτού του μαθήματος.

Οι υπηρεσίες μπορεί να έχουν εγγενή σφάλματα που επιτρέπουν την εκμετάλλευσή τους από επιτιθέμενους. Αυτές οι επιθέσεις συνήθως αφορούν στη χρήση ειδικών εντολών προς το λειτουργικό σύστημα, μέσω της ευάλωτης υπηρεσίας, για να γίνει καθήκοντος ο έλεγχος της διεργασίας που λειτουργεί την υπηρεσία δικτύου. Τα Buffer Overflows είναι μια κατηγορία τέτοιων επιθέσεων.

Ένα δίκτυο συνήθως φιλοξενεί πολλές εφαρμογές, κάποιες με απλά συστήματα σύνδεσης και άλλες με πολύπλοκη λειτουργικότητα. Ένας τρόπος για να αποκτήσουμε μια επισκόπηση της επιφάνειας επίθεσης (attack surface), και ταυτόχρονα να εντοπίσουμε εύκολα εκμεταλλεύσιμες ευπάθειες, είναι να σαρώσουμε τις θύρες (port scan) σε όλα τα περιουσιακά στοιχεία του περιβάλλοντος-στόχου και να τραβήξουμε στιγμιότυπα οθόνης (screenshots).

Εργαλεία όπως το EyeWitness (https://github.com/FortyNorthSecurity/EyeWitness) το επιτυγχάνουν αυτό. Το εργαλείο μας επιτρέπει γρήγορα να αποκτήσουμε μια εικόνα των πόρων που εκπροσωπούνται στο δίκτυο και στη συνέχεια παρέχει screenshots κάθε υπηρεσίας. Έχοντας τα στιγμιότυπα μπορούμε εύκολα να κοιτάξουμε και να αξιολογήσουμε γρήγορα ποια συστήματα χρειάζονται περαιτέρω διερεύνηση.

Η εκμετάλλευση μιας υπηρεσίας σημαίνει την κατάχρηση της υπηρεσίας με τρόπους που δεν προορίζονταν. Συχνά αυτή η δραστηριότητα εκμετάλλευσης σημαίνει ότι οι επιτιθέμενοι μπορούν να τρέξουν δικό τους κώδικα — αυτό καλείται RCE (Remote Code Execution).

---

## Buffer Overflow

Η εκμετάλλευση δικτυακών υπηρεσιών κάποιες φορές περιλαμβάνει την κατάχρηση λειτουργιών διαχείρισης μνήμης μιας εφαρμογής. Διαχείριση μνήμης; Ναι — οι εφαρμογές χρειάζεται να μετακινούν δεδομένα μέσα στη μνήμη του υπολογιστή για να λειτουργήσουν. Όταν οι γλώσσες προγραμματισμού δίνουν στον προγραμματιστή έλεγχο της μνήμης, μπορούν να προκύψουν προβλήματα όπως το Buffer Overflow. Υπάρχουν πολλές παρόμοιες ευπάθειες, και σε αυτή την ενότητα εξετάζουμε τα Buffer Overflows.

Οι γλώσσες προγραμματισμού C και C++ δίνουν στους προγραμματιστές μεγάλο έλεγχο του πώς διαχειρίζεται η μνήμη. Αυτό είναι ιδανικό για εφαρμογές που χρειάζονται χαμηλού επιπέδου πρόσβαση στο hardware, αλλά ανοίγει την πόρτα σε ευπάθειες. Γλώσσες όπως Java, JavaScript, C#, Ruby, Python και άλλες δεν επιτρέπουν εύκολα τέτοια λάθη, κάνοντας τα Buffer Overflows λιγότερο πιθανά σε εφαρμογές γραμμένες σε αυτές τις γλώσσες.

Τα Buffer Overflows συμβαίνουν όταν μη φιλτραρισμένες είσοδοι τοποθετούνται σε μεταβλητές. Αυτές οι μεταβλητές αναπαριστώνται στο λειτουργικό σύστημα μέσω μιας δομής μνήμης που ονομάζεται **στοίβα** (stack). Ο επιτιθέμενος μπορεί στη συνέχεια να αντικαταστήσει ένα τμήμα της στοίβας που ονομάζεται **Return Pointer**.

> **Σημείωση:** Η δομή μνήμης στοίβα (stack) είναι απλά το μέρος όπου ένα πρόγραμμα αποθηκεύει μεταβλητές και πληροφορίες που χρειάζεται για να τρέξει. Η στοίβα βρίσκεται στη RAM (Random Access Memory) του υπολογιστή.

Ο Return Pointer αποφασίζει πού ο CPU (Central Processing Unit) θα εκτελέσει τον επόμενο κώδικα. Ο CPU ελέγχει ποιες εντολές πρέπει να εκτελεστούν κάθε στιγμή. Ο return pointer είναι απλά μια διεύθυνση μνήμης όπου πρέπει να γίνει η εκτέλεση. Ο CPU πάντα πρέπει να του λέγεται πού να εκτελέσει κώδικα — και αυτό επιτυγχάνεται με τον return pointer.

Όταν ένας επιτιθέμενος καταφέρει να ελέγξει τον Return Pointer, σημαίνει ότι μπορεί να ελέγξει ποιες εντολές θα εκτελέσει ο CPU!

Για παράδειγμα, σκεφτείτε τον παρακάτω απλό κώδικα σε C (μην ανησυχείτε — δεν χρειάζεται να είστε προγραμματιστής C για να καταλάβετε την βασική ιδέα):

```c
#include <string.h>
void storeName (char *input) {
  char name[12];
  strcpy(name, input);
}

int main (int argc, char **argv) {
  storeName(argv[1]);
  return 0;
}
```

Σε πολλές γλώσσες προγραμματισμού, συμπεριλαμβανομένης της C, η εφαρμογή ξεκινά σε μια συνάρτηση που ονομάζεται `main`. Στον κώδικα παραπάνω η γραμμή `storeName(argv[1]);` δέχεται ό,τι πληκτρολογεί ο χρήστης ως παράμετρο και το περνάει στη συνάρτηση `storeName`.

Η εφαρμογή έχει 11 γραμμές κώδικα, αλλά εστιάστε στη γραμμή `strcpy(name, input);`. Αυτή είναι μια συνάρτηση που προσπαθεί να αντιγράψει το `input` μέσα στη μεταβλητή `name`. Η `name` μπορεί να χωρέσει το πολύ 12 χαρακτήρες όπως φαίνεται στη γραμμή `char name[12];`. Υπάρχει κάποιο σημείο στον κώδικα που εμποδίζει την προμήθεια περισσότερων από 12 χαρακτήρων; Όχι — το όνομα προέρχεται από τον χρήστη και περνάει απευθείας στη συνάρτηση χωρίς ελέγχους.

Σε αυτή την εφαρμογή δεν υπάρχει καθαρισμός ή φιλτράρισμα εισόδου, οπότε κάποιος μπορεί εύκολα να δώσει μεγαλύτερο όνομα από το αναμενόμενο. Η `name` χωράει 12 χαρακτήρες — αλλά τι συμβαίνει όταν ο CPU προσπαθήσει να γράψει περισσότερους από 12 χαρακτήρες; Θα εκτελέσει την εντολή και θα υπερχείλίσει (overwrite) όση μνήμη χρειαστεί!

Όταν προσπαθείται να γραφτεί μεγαλύτερη τιμή, ο CPU θα την γράψει στη μνήμη, προκαλώντας ενδεχομένως την υπερχείλιση άλλων περιοχών μνήμης, όπως ο Return Pointer — επιτρέποντας στον επιτιθέμενο να αποκτήσει έλεγχο του CPU. Αν ο επιτιθέμενος καταφέρει να αντικαταστήσει και να ελέγξει τον Return Pointer, ελέγχει το τι εκτελεί ο CPU.

Παρακάτω υπάρχει ένα γραφικό παράδειγμα όπου η Alice γράφει το όνομά της στην εφαρμογή που χρησιμοποιήσαμε στο παράδειγμα:

![Buffer Overflow](https://www.w3schools.com/cybersecurity/img_bufferoverflow.png)

Η Alice συμπεριφέρεται σωστά και δίνει ένα όνομα που κάνει την εφαρμογή να συμπεριφερθεί όπως πρέπει — το όνομα αποθηκεύεται στη μνήμη της εφαρμογής.

Η Eve όμως στέλνει πάρα πολλούς χαρακτήρες στην εφαρμογή. Τι συμβαίνει; Ο CPU γράφει την είσοδό της στη μνήμη, υπερχειλίζοντας και άλλες τιμές που υπάρχουν!

![Exploit Buffer Overflow](https://www.w3schools.com/cybersecurity/img_bufferoverflow-exploited.png)

Η είσοδος της Eve προκάλεσε τον CPU να γράψει περισσότερα δεδομένα από ό,τι περίμενε η εφαρμογή, και αυτό οδήγησε στην υπερχείλιση του return pointer. Όταν ο CPU προσπαθήσει να εκτελέσει την επόμενη εντολή, τώρα του λέγεται να εκτελέσει κώδικα στη θέση `AAAAAAA...`.

Εάν η Eve ήθελε να αναλάβει τον έλεγχο αυτού του server, αντί να γράψει απλά `A`s, θα έπρεπε να τοποθετήσει κώδικα που ο CPU μπορεί να καταλάβει στη μνήμη. Έπειτα θα ρύθμιζε τον return pointer σε μια διεύθυνση που δείχνει στον CPU να εκτελέσει τον δικό της κώδικα.

> **Σημείωση:** Με απλά λόγια, τα buffer overflows επιτρέπουν στους επιτιθέμενους να πάρουν τον έλεγχο της CPU ενός θύματος με το να υπερχειλίσουν προσεκτικά τη μνήμη του θύματος.

---

## Vulnerability Scanners (Σαρωτές Ευπαθειών)

Ένας vulnerability scanner αναζητά κοινές ευπάθειες σε λογισμικό και ρυθμίσεις σε όλο το δίκτυο, αυτόματα. Δεν έχει σχεδιαστεί για να βρίσκει νέες κατηγορίες ευπαθειών, αλλά χρησιμοποιεί μια λίστα προκαθορισμένων plugins (ή modules) για να σαρώσει υπηρεσίες για προβλήματα και ευπάθειες. Δεν αναζητά απαραίτητα zero-day ευπάθειες — δηλαδή νέες, άγνωστες ευπάθειες χωρίς διαθέσιμα patches.

Οι σαρωτές έχουν δυνατότητες network mapping και port scanning, καθώς και τρόπους να εξερευνήσουν και να εντοπίσουν ευπάθειες στις εφαρμογές που συναντούν.

Συχνά ένας vulnerability scanner υποστηρίζει ρύθμιση με credentials, επιτρέποντάς του να συνδεθεί σε συστήματα και να αξιολογήσει ευπάθειες από μια πιστοποιημένη προοπτική αντί να λειτουργεί ως μη-επιβεβαιωμένος (unauthenticated) εξερευνητής.

> **Σημείωση:** Οι Vulnerability scanners αναζητούν κυρίως γνωστές ευπάθειες και κακής ρύθμισης, όχι zero-day ευπάθειες.

---

## Εκτέλεση Κώδικα (Code Execution)

Όταν οι επιτιθέμενοι έχουν βρει μια ευπάθεια που μπορούν να εκμεταλλευτούν, πρέπει να αποφασίσουν ποιo payload θέλουν να τρέξουν. Το payload είναι ο κώδικας που θέλει να παραδώσει ο επιτιθέμενος μέσω ενός exploit.

Υπάρχουν πολλά διαφορετικά payloads που μπορεί να χρησιμοποιήσει ένας επιτιθέμενος — μερικά παραδείγματα:

- Να κάνουν το θύμα να εγγραφεί σε έναν C2 (Command and Control) server που δέχεται εντολές από τους επιτιθέμενους.
- Να δημιουργήσουν έναν νέο backdoor χρήστη στο σύστημα ώστε ο επιτιθέμενος να μπορεί να μπει αργότερα.
- Να ανοίξουν ένα GUI (Graphical User Interface) στο θύμα ώστε ο επιτιθέμενος να το ελέγχει απομακρυσμένα.
- Να λάβουν ένα command line terminal (shell) μέσω του οποίου ο επιτιθέμενος μπορεί να στείλει εντολές.

Ένα κοινό payload στους επιτιθέμενους είναι το **bind-shell**. Προκαλεί το θύμα να ακούει σε μια θύρα, και όταν ο επιτιθέμενος συνδεθεί, λαμβάνει ένα shell.

![Bind Shell](https://www.w3schools.com/cybersecurity/img_bind-shell.svg)

Τα firewalls βοηθούν στο να αποτρέψουν τους επιτιθέμενους από το να συνδεθούν με τα θύματα. Ένα firewall θα απορρίψει εισερχόμενες συνδέσεις στο θύμα εφόσον η θύρα δεν επιτρέπεται. Μόνο μια εφαρμογή μπορεί να ακούει σε μια θύρα, οπότε οι επιτιθέμενοι δεν μπορούν να ακούνε σε θύρες που χρησιμοποιούνται ήδη, εκτός αν απενεργοποιήσουν την υπηρεσία.

Για να παρακαμφθεί αυτό το μέτρο, οι επιτιθέμενοι συχνά προσπαθούν να κάνουν το θύμα να συνδεθεί στον επιτιθέμενο, κάνοντας το θύμα να εξυπηρετήσει το payload. Πολλά firewalls δυστυχώς δεν ρυθμίζονται να μπλοκάρουν την εξερχόμενη κίνηση (egress), κάνοντας αυτή την επίθεση πολύ εφικτή.

Σε αυτό το παράδειγμα βλέπουμε έναν επιτιθέμενο να χρησιμοποιεί ένα **reverse-shell** για να κάνει το θύμα να συνδεθεί στον επιτιθέμενο.

![Reverse Shell](https://www.w3schools.com/cybersecurity/img_reverse-shell.svg)

> **Σημείωση:** Η εκτέλεση κώδικα σημαίνει ότι οι επιτιθέμενοι μπορούν να τρέξουν τον δικό τους κώδικα στο σύστημα του θύματος. Τι θα επιλέξουν να τρέξουν εξαρτάται από αυτούς, αλλά συχνά αφορά τον μακροχρόνιο έλεγχο του θύματος.

---

## Παρακολούθηση Δικτύου (Network Monitoring)

Οι επιτιθέμενοι στις περισσότερες περιπτώσεις χρειάζονται το δίκτυο για να ελέγχουν απομακρυσμένα έναν στόχο. Όταν οι επιτιθέμενοι μπορούν να ελέγχουν απομακρυσμένα έναν στόχο, αυτό γίνεται μέσω ενός κανάλιου Command and Control, συχνά ονομαζόμενου C&C ή C2.

Υπάρχουν κακόβουλα προγράμματα (malware) που είναι προ-προγραμματισμένα με payloads και δεν χρειάζονται C2 — αυτά μπορούν να συμβάλουν ακόμη και σε συμβιβασμούς air-gapped δικτύων.

Η ανίχνευση συμβιβασμών συχνά γίνεται μέσω του εντοπισμού του C2 καναλιού. Το C2 μπορεί να πάρει πολλές μορφές, για παράδειγμα:

- Χρήση HTTPS για επικοινωνία με servers των επιτιθέμενων — το C2 μοιάζει με κανονική περιήγηση στο διαδίκτυο.
- Χρήση κοινωνικών δικτύων για αυτόματη ανάγνωση/ανάρτηση μηνυμάτων.
- Χρήση συστημάτων όπως το Google Docs για να προσθέτουν και να επεξεργάζονται εντολές για τα θύματα.

![Network Monitoring Beacon](https://www.w3schools.com/cybersecurity/img_networkmonitoring-beacon.png)

Μόνο η εφευρετικότητα του επιτιθέμενου βάζει όρια στο C2. Όταν σκεφτόμαστε πώς να σταματήσουμε τους επιτιθέμενους που χρησιμοποιούν έξυπνα C2 κανάλια, συχνά βασιζόμαστε στον εντοπισμό στατιστικών ανωμαλιών και αποκλίσεων στο δίκτυο. Για παράδειγμα, εργαλεία παρακολούθησης δικτύου μπορούν να εντοπίσουν:

- Μακροχρόνιες συνδέσεις χρήσης του C2 που είναι αφύσικες για το πρωτόκολλο (π.χ. HTTP δεν είναι συνήθως μακροχρόνιο).
- Beacons που χρησιμοποιούνται από το C2 για να υποδείξουν ότι το θύμα είναι «ζωντανό» και έτοιμο για εντολές. Τα beacons χρησιμοποιούνται και από νόμιμες εφαρμογές, αλλά το να γνωρίζουμε ποια είναι αναμενόμενα είναι καλό πρακτικό μέτρο.
- Ξαφνικές εκρήξεις δεδομένων (strobes) που αναβλύζουν από το δίκτυο — αυτό μπορεί να υποδεικνύει μεγάλη αποστολή δεδομένων ή κλοπή. Προσπαθήστε να καταλάβετε ποια εφαρμογή και ποιος χρήστης προκάλεσε το strobes και εφαρμόστε context: Είναι φυσιολογικό ή όχι;

Υπάρχουν πολλοί τρόποι με τους οποίους οι αμυνόμενοι μπορούν να εντοπίσουν ανωμαλίες. Αυτές οι ανωμαλίες πρέπει να συσχετιστούν περαιτέρω με δεδομένα από το σύστημα πηγής που στέλνει την κίνηση.

Για την παρακολούθηση δικτύου, πρέπει να εφαρμοστεί context για να διαχωριστεί ο θόρυβος από το σήμα. Αυτό σημαίνει ότι ένα SOC (Security Operations Center) θα πρέπει να εμπλουτίζει δεδομένα, π.χ. διευθύνσεις IP πηγής και προορισμού με πρόσθετο context για να κάνουν τα δεδομένα πιο χρήσιμα.

Η εφαρμογή context μπορεί να εξηγηθεί με το εξής παράδειγμα: Μια επίθεση έρχεται από το Internet αλλά προσπαθεί να εκμεταλλευτεί μια ευπάθεια Linux εναντίον μιας υπηρεσίας Windows. Αυτό θα θεωρούνταν συνήθως ως θόρυβος και θα μπορούσε να αγνοηθεί — εκτός αν η διεύθυνση IP που έκανε την επίθεση είναι διεύθυνση του δικού σας δικτύου ή ενός αξιόπιστου παρόχου. Το context τότε μπορεί να δώσει πολύτιμες ενδείξεις για περαιτέρω διερεύνηση. Δεν θέλουμε συστήματα που εμπιστευόμαστε να εκκινούν επιθέσεις!

---

## Peer-to-Peer Κίνηση (Peer to Peer Traffic)

Τα περισσότερα δίκτυα είναι ρυθμισμένα σε μοντέλο client–server: οι clients προσπελαύνουν servers για πληροφορίες, και όταν οι clients χρειάζεται να επικοινωνήσουν μεταξύ τους, τυπικά το κάνουν μέσω ενός server.

Ένας επιτιθέμενος όμως πιθανότατα θα θελήσει να χρησιμοποιήσει peer-to-peer (client–client) επικοινωνίες για να εκμεταλλευτεί ευκαιρίες όπως η επαναχρησιμοποίηση credentials ή ευάλωτοι clients.

Για παράδειγμα, η θύρα 445 (SMB) είναι καλός δείκτης για τον εντοπισμό συμβιβασμών. Σε πολλά περιβάλλοντα οι clients δεν πρέπει να μιλάνε μεταξύ τους μέσω SMB — όμως κατά τη διάρκεια ενός συμβιβασμού είναι πιθανό οι επιτιθέμενοι να χρησιμοποιήσουν το SMB για να προχωρήσουν σε περαιτέρω συμβιβασμούς.

![Peer-to-Peer](https://www.w3schools.com/cybersecurity/img_peer-to-peer.svg)

---

## Lateral Movement και Pivoting

Μόλις ένα σύστημα έχει συμβιβαστεί, ένας επιτιθέμενος μπορεί να το χρησιμοποιήσει για να εξερευνήσει επιπλέον δίκτυα στα οποία έχει πρόσβαση το συμβιβασμένο σύστημα. Αυτό είναι εφικτό σε περιβάλλοντα όπου ένα συμβιβασμένο σύστημα έχει περισσότερα προνόμια μέσω του firewall ή έχει πρόσβαση σε άλλα δίκτυα, π.χ. μέσω επιπλέον κάρτας δικτύου.

Το pivoting σημαίνει ότι ο επιτιθέμενος χρησιμοποιεί έναν συμβιβασμένο host για να φτάσει σε άλλα δίκτυα. Μια απεικόνιση αυτού φαίνεται εδώ όπου η Eve έχει συμβιβαστεί ένα σύστημα και το χρησιμοποιεί για να σαρώσει και να ανακαλύψει άλλα συστήματα:

![Pivoting Lateral Movement](https://www.w3schools.com/cybersecurity/img_pivoting-lateral-movement.svg)

Το Lateral Movement είναι η ενέργεια αξιοποίησης του pivot για την εκμετάλλευση άλλου συστήματος χρησιμοποιώντας το pivot. Αυτό το νέο σύστημα μπορεί στη συνέχεια να χρησιμοποιηθεί περαιτέρω για επιπλέον pivoting και lateral movement. Στο παράδειγμά μας η Eve χρησιμοποιεί τον Server X για να ανακαλύψει το System B.

![Pivoting Lateral Movement 2](https://www.w3schools.com/cybersecurity/img_pivoting-lateral-movement2.svg)

---

